1. Which is the most succinct query to return all documents from the sample_training.
inspections collection where the inspection date is either "Feb 20 2015", or "Feb 21 2015" 
and the company is not part of the "Cigarette Retail Dealer - 127" sector?

  db.inspections.find(
    { "$or": [ { "date": "Feb 20 2015" },
               { "date": "Feb 21 2015" } ],
      "sector": { "$ne": "Cigarette Retail Dealer - 127" }}).pretty()
  This is correct.
  
  This query accounts for both dates that we are looking for and excludes all documents where the sector is "Cigarette Retail Dealer - 127" by using the $ne not equal comparison operator.
  
  db.inspections.find(
    { "$or": [ { "date": "Feb 20 2015" },
               { "date": "Feb 21 2015" }],
      "$not": { "sector": "Cigarette Retail Dealer - 127" }}).pretty()
  This is incorrect.
  
  While this query looks for the right dates and correctly uses the $or operator, 
  it is incorrectly using the $not logic operator. $not negates a logical expression, 
  and in this case, will result in an error.
  
  db.inspections.find(
    { "$and": [
        { "$or": [
                   { "date": "Feb 20 2015" },
                   { "date": "Feb 21 2015" } ] },
        {"sector": { "$ne":"Cigarette Retail Dealer - 127" }}]
    }).pretty()
  This is incorrect.
  
  This statement will return the correct documents, but it is unnecessarily using the $and operator 
  and thus can not be the best way to get the required documents.


2. How many companies in the sample_training.companies dataset were

  either founded in 2004
  
  [and] either have the social category_code [or] web category_code,
  [or] were founded in the month of October
  
  [and] also either have the social category_code [or] web category_code?

  db.companies.find({"$or": [{"$and": [{"founded_year":2004},{"$or":[{"category_code":"social"},{"category_code":"web"}]}]},
  {"$and": [{"founded_month":10},{"$or":[{"category_code":"social"},{"category_code":"web"}]}]}]}).count();


3. What is the name of the listing in the sample_airbnb.listingsAndReviews dataset 
that accommodates more than 6 people and has exactly 50 reviews?

  db.listingsAndReviews.find({ "reviews": { "$size":50 },
                             "accommodates": { "$gt":6 }})


4. Which of the following commands will return the name and founding year for the 5 oldest companies 
in the sample_training.companies collection?

db.companies.find({"founded_year": {"$ne":null}},{"name":1,"founded_year":1}).sort({"founded_year":1}).limit(5);
db.companies.find({"founded_year": {"$ne":null}},{"name":1,"founded_year":1}).limit(5).sort({"founded_year":1});
都可以，sort在limit前先执行，无论MQL顺序


5. Gving index { name: 1, emails: 1 }
When the following document is inserted, how many index entries will be created?
{
  "name": "Beatrice McBride",
  "age": 26,
  "emails": [
      "puovvid@wamaw.kp",
      "todujufo@zoehed.mh",
      "fakmir@cebfirvot.pm"
  ]
}

answer: 3
"Beatrice McBride", "puovvid@wamaw.kp"
"Beatrice McBride", "todujufo@zoehed.mh"
"Beatrice McBride", "fakmir@cebfirvot.pm"

6. Using the wildcardProjection flag with Wildcard Indexes, we can:

Correct Answers:

Using the wildcardProjection flag with Wildcard Indexes, we can:

include a set of fields in the Wildcard Index.

We can include a set of fields in our Wildcard Index using the syntax { wildcardProjection: { <field.path>: 1 } }.
exclude a set of fields from the Wildcard Index.

We can exclude a set of fields from our Wildcard Index using the syntax { wildcardProjection: { <field.path>: 0 } }.
Incorrect Answer:

Using the wildcardProjection flag with Wildcard Indexes, we can specify a set of fields 
in the Wildcard Index to project with $project. This is not the purpose of the wildcardProjection flag.


7. Which of the following are good reasons to use a Wildcard Index?
1) Correct Options

The query pattern on documents of a collection is unpredictable.

The wildcard index creates an index on every field in a document or subdocument, 
which facilitates an unpredictable query pattern.

An application consistently queries against document fields that use the Attribute Pattern.

The wildcard index can create an index on every field in a subdocument, 
which eliminates the need for an array of subdocuments when implementing the Attribute Pattern.

2) Incorrect Option

A collection has documents with many different fields.

This is not enough to justify using a Wildcard Index. 
If a collection has many different fields, and you wanted to support queries on all those fields, 
then the Wildcard Index is a viable option. 
However, simply having many different fields is not a good reason to use the Wildcard Index.